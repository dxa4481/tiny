#!/usr/bin/env python3
"""
Post-process GDS to Add Text Art

This script adds text as polygons to an existing GDS file generated by OpenLane.
It's designed to work with TinyTapeout designs and adds text to metal layers
that will be visible under a microscope.

The text is added to the metal 4 layer (met4) by default, which is above
most routing and won't interfere with the design's functionality.

Usage:
    python add_text_to_gds.py input.gds output.gds "Hello World!"
    
Or for the TinyTapeout flow, this can be run as a post-processing step.
"""

import argparse
import sys
from pathlib import Path

try:
    import gdstk
except ImportError:
    print("Error: gdstk library required. Install with: pip install gdstk")
    sys.exit(1)


# Sky130 PDK layer definitions
SKY130_LAYERS = {
    'met1': {'layer': 68, 'datatype': 20},
    'met2': {'layer': 69, 'datatype': 20},
    'met3': {'layer': 70, 'datatype': 20},
    'met4': {'layer': 71, 'datatype': 20},
    'li1':  {'layer': 67, 'datatype': 20},
    # Label layers (for text annotations, not physical)
    'met1_label': {'layer': 68, 'datatype': 5},
    'met2_label': {'layer': 69, 'datatype': 5},
    'met3_label': {'layer': 70, 'datatype': 5},
    'met4_label': {'layer': 71, 'datatype': 5},
}

# TinyTapeout 1x1 tile dimensions
TILE_WIDTH = 161.0   # um
TILE_HEIGHT = 111.52  # um


def add_text_to_gds(input_gds, output_gds, text, layer='met4', 
                    font_size=None, position='center', margin=5.0):
    """
    Add text to an existing GDS file.
    
    Args:
        input_gds: Path to input GDS file
        output_gds: Path to output GDS file
        text: Text string to add (use \\n for newlines)
        layer: Metal layer for text
        font_size: Font size in um (auto-calculated if None)
        position: 'center', 'top', 'bottom', or (x, y) tuple
        margin: Margin from edges in um
    """
    # Read input GDS
    lib = gdstk.read_gds(input_gds)
    
    if not lib.cells:
        print(f"Error: No cells found in {input_gds}")
        sys.exit(1)
    
    # Find the top cell (usually the last one or the one with most references)
    top_cell = lib.top_level()
    if not top_cell:
        top_cell = [lib.cells[-1]]
    
    cell = top_cell[0]
    print(f"Adding text to cell: {cell.name}")
    
    # Get cell bounding box
    bbox = cell.bounding_box()
    if bbox is None:
        print("Warning: Cell has no bounding box, using default tile size")
        cell_width = TILE_WIDTH
        cell_height = TILE_HEIGHT
        cell_min_x = 0
        cell_min_y = 0
    else:
        cell_width = bbox[1][0] - bbox[0][0]
        cell_height = bbox[1][1] - bbox[0][1]
        cell_min_x = bbox[0][0]
        cell_min_y = bbox[0][1]
    
    print(f"Cell size: {cell_width:.2f} x {cell_height:.2f} um")
    
    # Get layer info
    if layer not in SKY130_LAYERS:
        print(f"Unknown layer: {layer}. Available: {list(SKY130_LAYERS.keys())}")
        sys.exit(1)
    
    layer_num = SKY130_LAYERS[layer]['layer']
    datatype = SKY130_LAYERS[layer]['datatype']
    
    # Calculate available area for text
    avail_width = cell_width - 2 * margin
    avail_height = cell_height - 2 * margin
    
    # Calculate font size if not specified
    if font_size is None:
        lines = text.split('\n')
        max_line_len = max(len(line) for line in lines)
        num_lines = len(lines)
        
        # gdstk text dimensions
        char_width_ratio = 9/16
        line_spacing_ratio = 5/4
        
        text_width_per_size = max_line_len * char_width_ratio
        text_height_per_size = 1 + (num_lines - 1) * line_spacing_ratio
        
        max_font_by_width = avail_width / text_width_per_size if text_width_per_size > 0 else 10
        max_font_by_height = avail_height / text_height_per_size if text_height_per_size > 0 else 10
        
        font_size = min(max_font_by_width, max_font_by_height) * 0.8  # 80% to leave margin
        font_size = max(font_size, 1.0)  # Minimum 1um
    
    print(f"Using font size: {font_size:.2f} um")
    
    # Create text polygons
    text_polys = gdstk.text(text, font_size, (0, 0), 
                           layer=layer_num, datatype=datatype)
    
    if not text_polys:
        print("Warning: No polygons generated for text")
        return
    
    # Get text bounding box
    all_points = []
    for poly in text_polys:
        all_points.extend(poly.points)
    
    text_xs = [p[0] for p in all_points]
    text_ys = [p[1] for p in all_points]
    text_width = max(text_xs) - min(text_xs)
    text_height = max(text_ys) - min(text_ys)
    text_min_x = min(text_xs)
    text_min_y = min(text_ys)
    
    # Calculate position
    if position == 'center':
        offset_x = cell_min_x + cell_width/2 - text_width/2 - text_min_x
        offset_y = cell_min_y + cell_height/2 - text_height/2 - text_min_y
    elif position == 'top':
        offset_x = cell_min_x + cell_width/2 - text_width/2 - text_min_x
        offset_y = cell_min_y + cell_height - margin - text_height - text_min_y
    elif position == 'bottom':
        offset_x = cell_min_x + cell_width/2 - text_width/2 - text_min_x
        offset_y = cell_min_y + margin - text_min_y
    elif isinstance(position, (list, tuple)):
        offset_x = position[0] - text_min_x
        offset_y = position[1] - text_min_y
    else:
        offset_x = margin - text_min_x
        offset_y = margin - text_min_y
    
    # Add translated polygons to cell
    for poly in text_polys:
        translated = poly.translate(offset_x, offset_y)
        cell.add(translated)
    
    print(f"Added {len(text_polys)} polygons on layer {layer} ({layer_num}:{datatype})")
    
    # Save output
    lib.write_gds(output_gds)
    print(f"Saved to: {output_gds}")


def main():
    parser = argparse.ArgumentParser(
        description='Add text art to an existing GDS file',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    # Add centered text
    python add_text_to_gds.py design.gds design_art.gds "Hello!"
    
    # Add text on metal 3 layer
    python add_text_to_gds.py design.gds out.gds "Art" --layer met3
    
    # Custom font size
    python add_text_to_gds.py design.gds out.gds "Small" --font-size 3.0
    
    # Position at top
    python add_text_to_gds.py design.gds out.gds "Title" --position top
        """
    )
    
    parser.add_argument('input', help='Input GDS file')
    parser.add_argument('output', help='Output GDS file')
    parser.add_argument('text', help='Text to add (use \\n for newlines)')
    parser.add_argument('--layer', '-l', default='met4',
                       choices=list(SKY130_LAYERS.keys()),
                       help='Layer for text (default: met4)')
    parser.add_argument('--font-size', '-s', type=float, default=None,
                       help='Font size in um (auto-calculated if not specified)')
    parser.add_argument('--position', '-p', default='center',
                       help='Position: center, top, bottom, or "x,y" coordinates')
    parser.add_argument('--margin', '-m', type=float, default=5.0,
                       help='Margin from edges in um (default: 5.0)')
    
    args = parser.parse_args()
    
    # Parse position
    if args.position in ['center', 'top', 'bottom']:
        position = args.position
    else:
        try:
            parts = args.position.split(',')
            position = (float(parts[0]), float(parts[1]))
        except:
            position = 'center'
    
    # Handle escaped newlines
    text = args.text.replace('\\n', '\n')
    
    add_text_to_gds(
        args.input,
        args.output,
        text,
        layer=args.layer,
        font_size=args.font_size,
        position=position,
        margin=args.margin
    )


if __name__ == '__main__':
    main()
